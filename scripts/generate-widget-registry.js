const fs = require("fs/promises");
const path = require("path");

// --- CONFIGURATION ---
// These paths are set up to work from the project root.

// __dirname is the path to the current folder ('/path/to/your-project/scripts')
const PROJECT_ROOT = path.resolve(__dirname, ".."); // Go up one level to the project root

// Define paths relative to the project root
const WIDGETS_DIR = path.join(PROJECT_ROOT, "src", "widgets");
const OUTPUT_FILE = path.join(WIDGETS_DIR, "core", "autogen.ts");
// --- END CONFIGURATION ---

/**
 * Main function that generates the widget registry.
 */
async function generateWidgetRegistry() {
  console.log("🚀 Starting widget generator...");
  console.log(`🔎 Scanning folder: ${WIDGETS_DIR}`);

  try {
    const allFiles = await fs.readdir(WIDGETS_DIR);
    const widgetInfos = [];

    // Find all widget classes with decorator
    for (const file of allFiles) {
      // Detect .ts and .tsx, ignore the generated file and the base class
      if (!/\.tsx?$/.test(file) || file.includes("autogen") || file.includes("BoraWidget")) {
        continue;
      }

      const filePath = path.join(WIDGETS_DIR, file);
      const content = await fs.readFile(filePath, "utf8");

      // Robust regex for the decorator (allows ' and " and - in the name)
      const decoratorMatch = content.match(/@registerWidget\(['"]([\w-]+)['"]\)/);
      const classMatch = content.match(/export class (\w+)/);

      if (decoratorMatch && classMatch) {
        const typeName = decoratorMatch[1];
        const className = classMatch[1];
        const interfaceName = `I${className}`;
        const importPath = `../${file.replace(/\.tsx?$/, "")}`; // Removes .ts or .tsx

        widgetInfos.push({ typeName, className, interfaceName, importPath });
        console.log(`✅ Widget found: ${className} (Type: ${typeName})`);
      }
    }

    if (widgetInfos.length === 0) {
      console.warn("\n⚠️ No widgets with @registerWidget decorator found. Check the files in the widgets folder.");
      return;
    }

    const fileContent = generateFileContent(widgetInfos);

    await fs.writeFile(OUTPUT_FILE, fileContent);
    console.log(`\n🎉 Success! Registry was successfully created at ${OUTPUT_FILE}.`);
  } catch (error) {
    console.error(`\n❌ Error: Could not read folder ${WIDGETS_DIR}. Is the path in the configuration correct?`);
    console.error(error.message);
    process.exit(1);
  }
}

/**
 * Builds the string content for the generated TypeScript file.
 * (This function remains unchanged)
 */
function generateFileContent(widgets) {
  const classImports = widgets.map(w => `import { ${w.className} } from '${w.importPath}';`).join("\n");
  const interfaceImports = `import { ${widgets.map(w => w.interfaceName).join(", ")} } from '@/types/widgets';`;
  const unionType = `export type IWidget = ${widgets.map(w => w.interfaceName).join(" | ")};`;
  const instances = widgets.map(w => `const ${w.className.toLowerCase()}Instance = new ${w.className}();`).join("\n");
  const registryEntries = widgets.map(w => `  "${w.typeName}": ${w.className.toLowerCase()}Instance,`).join("\n");
  const registryObject = `export const widgetRegistry = {\n${registryEntries}\n} as const;`;
  const registryKeysType = `export type WidgetType = keyof typeof widgetRegistry;`;

  return `// 🤖 AUTOGENERATED FILE - DO NOT EDIT MANUALLY!\n
${classImports}
${interfaceImports}

/** A union type representing the data structure of every possible widget. */
${unionType}

/** A type containing all possible widget type strings (e.g. "TEXT" | "IMAGE"). */
${registryKeysType}

// Singleton instances for each widget handler
${instances}

/** * A central registry that maps each widget type string to the corresponding 
 * handler instance.
 */
${registryObject}
`;
}

// Run script
generateWidgetRegistry();