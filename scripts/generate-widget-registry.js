const fs = require("fs/promises");
const path = require("path");

// --- CONFIGURATION ---
// These paths are set up to work from the project root.

// __dirname is the path to the current folder ('/path/to/your-project/scripts')
const PROJECT_ROOT = path.resolve(__dirname, ".."); // Go up one level to the project root

// Define paths relative to the project root
const WIDGETS_DIR = path.join(PROJECT_ROOT, "src", "widgets");
const OUTPUT_FILE_SERVER = path.join(WIDGETS_DIR, "core", "autogen.ts");
const OUTPUT_FILE_CLIENT = path.join(WIDGETS_DIR, "core", "autogen.client.ts");
// --- END CONFIGURATION ---

/**
 * Main function that generates the widget registry.
 */
async function generateWidgetRegistry() {
  console.log("ðŸš€ Starting widget generator...");
  console.log(`ðŸ”Ž Scanning folder: ${WIDGETS_DIR}`);

  try {
    const allFiles = await fs.readdir(WIDGETS_DIR);
    const widgetInfos = [];

    // Find all widget classes with decorator
    for (const file of allFiles) {
      // Detect .ts and .tsx, ignore the generated file and the base class
      if (!/\.tsx?$/.test(file) || file.includes("autogen") || file.includes("BoraWidget")) {
        continue;
      }

      const filePath = path.join(WIDGETS_DIR, file);
      const content = await fs.readFile(filePath, "utf8");

      // Robust regex for the decorator (allows ' and " and - in the name)
      const decoratorMatch = content.match(/@registerWidget\(['"]([\w-]+)['"]\)/);
      const classMatch = content.match(/export class (\w+)/);

      if (decoratorMatch && classMatch) {
        const typeName = decoratorMatch[1];
        const className = classMatch[1];
        const interfaceName = `I${className}`;
        const importPath = `../${file.replace(/\.tsx?$/, "")}`; // Removes .ts or .tsx

        widgetInfos.push({ typeName, className, interfaceName, importPath });
        console.log(`âœ… Widget found: ${className} (Type: ${typeName})`);
      }
    }

    if (widgetInfos.length === 0) {
      console.warn("\nâš ï¸ No widgets with @registerWidget decorator found. Check the files in the widgets folder.");
      return;
    }

  const serverContent = generateServerFile(widgetInfos);
  const clientContent = generateClientFile(widgetInfos);

  await fs.writeFile(OUTPUT_FILE_SERVER, serverContent);
  console.log(`\nâœ… Server file created: ${OUTPUT_FILE_SERVER}`);
  await fs.writeFile(OUTPUT_FILE_CLIENT, clientContent);
  console.log(`âœ… Client file created: ${OUTPUT_FILE_CLIENT}`);
  console.log(`\nðŸŽ‰ Success! Widget registry generation complete.`);
  } catch (error) {
    console.error(`\nâŒ Error: Could not read folder ${WIDGETS_DIR}. Is the path in the configuration correct?`);
    console.error(error.message);
    process.exit(1);
  }
}

/**
 * Builds the string content for the generated TypeScript file.
 * (This function remains unchanged)
 */
function generateServerFile(widgets) {
  const interfaceImports = `import { ${widgets.map(w => w.interfaceName).join(", ")} } from '@/types/widgets';`;
  const iWidgetUnion = `export type IWidget = ${widgets.map(w => w.interfaceName).join(" | ")};`;
  const widgetTypeUnion = `export type WidgetType = ${widgets.map(w => `"${w.typeName}"`).join(" | ")};`;
  const widgetTypesArray = `export const widgetTypes = [${widgets.map(w => `"${w.typeName}"`).join(", ")}] as const;`;
  return `// ðŸ¤– AUTOGENERATED FILE (SERVER) - DO NOT EDIT MANUALLY!\n// Contains only types + metadata (no class imports).\n\n${interfaceImports}\n\n${iWidgetUnion}\n${widgetTypeUnion}\n${widgetTypesArray}\n`;
}

function generateClientFile(widgets) {
  const classImports = widgets.map(w => `import { ${w.className} } from '${w.importPath}';`).join("\n");
  const instances = widgets.map(w => `const ${w.className}Instance = new ${w.className}();`).join("\n");
  const registryEntries = widgets.map(w => `  "${w.typeName}": ${w.className}Instance,`).join("\n");
  const registryObject = `export const widgetRegistry = {\n${registryEntries}\n} as const;`;
  return `"use client";\n\n// ðŸ¤– AUTOGENERATED FILE (CLIENT) - DO NOT EDIT MANUALLY!\n// Provides widgetRegistry with instantiated widget handler classes.\n\n${classImports}\n\n// Singleton instances\n${instances}\n\n// Registry mapping type -> handler instance\n${registryObject}\n`;
}

// Run script
generateWidgetRegistry();